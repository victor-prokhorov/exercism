# | Register | Usage        | Type    | Description                   |
# | -------- | ------------ | ------- | ----------------------------- |
# | `$a0`    | input        | address | null-terminated input string  |
# | `$a1`    | input/output | address | null-terminated output string |
# | `$t0-9`  | temporary    | any     | for temporary storage         |

# we have a grid of 3 by 3, at flatten index 5
# 5 / 3; lo(quot) = 1; hi(rem) = 2; (2, 1) 0-indexed
# 
# 1    2     3           hi, index-1-3..index-1
#
# 4  <cell>  5           mi, index-1, index+1
#
# 6    7     8           lo, index+1..index+1+3
#
# ...
# x..   
# ...
#
# index=3, 3/3=>lo=1;hi=0;
# left => index-1 => |0,2| does not include hi=0
# top => index-1-2 => |0,2| does include lo=1

.globl annotate

annotate:
        move    $t0, $a0                        # `$a0`
        move    $t1, $a1                        # `$a1`
        li      $t2, 0                          # width, row length
        li      $t3, 0                          # height, column length
        li      $t5, 0                          # first row flag
calc_width_height_loop:
        lb      $t4, ($t0)                      # character, cell or formatting such as `\n` or `\0`
        beq     $t4, '\0', write_loop_setup 
        beq     $t4, '\n', set_flag             # we bump into `\n` so we set first row flag
        addi    $t3, $t3, 1                     # right now we simply accumulate into `$t3` all characters count
        beq     $t5, 1, skip_increment          # if we set the flag we don't increment anymore
        addi    $t2, $t2, 1
        j       skip_increment
set_flag:
        li      $t5, 1
skip_increment:
        addi    $t0, $t0, 1
        j       calc_width_height_loop
write_loop_setup:
        div     $t3, $t2                        # divide all cells count by first row count
        mflo    $t3                             # quotient is the height
        li      $t4, 0                          # flatten cell index
        move    $t0, $a0
        move    $t1, $a1
write_loop:                                     # each iteration handle single cell
        li      $t5, 0                          # mine count for the cell
        lb      $t6, ($t0)                      # cell character
        beq     $t6, '\0', end
        beq     $t6, '\n', write_same
        beq     $t6, '*', write_same            # after this line we start to process the cell
        div     $t4, $t3                        # divide flatten cell index by width
        mflo    $t8                             # y-coordinate (quotient)
        mfhi    $t9                             # x-coordinate (remainder)
# tmp just left offset
        subi    $t9, $t9, 1
        blt     $t9, $zero, no_mines
        bgt     $t9, $t2, no_mines              # after this line we know that the offset is valid
        lb      $t6, -1($t0)                    # but we still need to find out if there some mines
        bne     $t6, '*', no_mines
        addi    $t5, $t5, 1
# tmp just left offset
no_mines: # write character
        li      $t7, '0'                        # mine count as character
        add     $t7, $t7, $t5                   # add mine count
        bne     $t7, '0', non_zero_mine_count
        li      $t7, ' '                        # we render ' ' instead of '0'
non_zero_mine_count:
        sb      $t7, ($t1)
        addi    $t0, $t0, 1                     # todo: i prefer to increment everything at the end (it's easier to do arithmetics) but i have to repeat those 3 lines
        addi    $t1, $t1, 1
        addi    $t4, $t4, 1
        j       write_loop
write_same:
        sb      $t6, ($t1)
        addi    $t0, $t0, 1
        addi    $t1, $t1, 1
        # addi    $t4, $t4, 1 # !!! we don't increment this it's not a cell
        j       write_loop
end:
        jr      $ra


#         li      $t4, 0                          # all characters until zero termination count
# size:
#         lb      $t2, ($t0)
#         addi    $t0, $t0, 1
#         addi    $t4, $t4, 1                     # always increment
#         bne     $t2, '\n', skip_n_count         # increment if new line
#         addi    $t3, $t3, 1
# skip_n_count:
#         bne     $t2, '\0', size
#         sub     $t5, $t4, $t3                   # non new lines characters
#         div     $t5, $t3
#         mflo    $t4                             # columns, **x len**
#         li      $t5, 0                          # flatten index, we will build (x, y) from it
#         move    $t0, $a0
#         move    $t1, $a1
# loop:
#         li      $t9, 0                          # mines count
#         lb      $t2, ($t0)
#         # check offseted cells
#         div     $t5, $t3
#         mflo    $t6                             # quotient, y coordinate
#         mfhi    $t7                             # remainder, x coordinate
#         # left
#         subi     $t8, $t7, 1                     # left x coord
#         # $t8 >= 0 && $t8 < 3 && lb == '*' => $t9++
#         bltz    $t8, next_check
#         bge     $t8, $t4, next_check
#         # index is in range horizontally, safe to load
#         lb      $t5, -1($t0)                     # character at offset (left)
#         beq     $t5, '*', increment
#
# # ! i have overlaps on t3 and t5 it wont work !
#
# next_check:
#         li      $t5, '0'
#         add     $t5, $t3, $t9
#         bne     $t5, '0', count
#         li      $t5, ' '
# count:
#         beq     $t2, '\n', skip_count
#         addi    $t5, $t5, 1                     # increment characters count (wihtou \n)
# skip_count:
#         sb      $t2, ($t1)                      # and store '\n'
#         # increment both ptrs at the end
#         addi    $t1, $t1, 1
#         addi    $t0, $t0, 1
#         bne     $t2, '\0', loop
# end:
#         # li      $t2, '\0'
#         # sb      $t2, ($t1)
#         jr      $ra
# 
# increment:
#         addi    $t9, $t9, 1
#         j       next_check
