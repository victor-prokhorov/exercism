# | Register | Usage        | Type    | Description                   |
# | -------- | ------------ | ------- | ----------------------------- |
# | `$a0`    | input        | address | null-terminated input string  |
# | `$a1`    | input/output | address | null-terminated output string |
# | `$t0-9`  | temporary    | any     | for temporary storage         |

# we have a grid of 3 by 3, at flatten index 5
# 5 / 3; lo(quot) = 1; hi(rem) = 2; (2, 1) 0-indexed
# 
# 1    2     3           hi, index-1-3..index-1
#
# 4  <cell>  5           mi, index-1, index+1
#
# 6    7     8           lo, index+1..index+1+3
#
# ...
# x..   
# ...
#
# index=3, 3/3=>lo=1;hi=0;
# left => index-1 => |0,2| does not include hi=0
# top => index-1-2 => |0,2| does include lo=1

.globl annotate

annotate:
        move    $t0, $a0
        move    $t1, $a1
        li      $t3, 0                          # new lines count, rows, **y len**
        li      $t4, 0                          # all characters until zero termination count
size:
        lb      $t2, ($t0)
        addi    $t0, $t0, 1
        addi    $t4, $t4, 1                     # always increment
        bne     $t2, '\n', skip_n_count         # increment if new line
        addi    $t3, $t3, 1
skip_n_count:
        bne     $t2, '\0', size
        sub     $t5, $t4, $t3                   # non new lines characters
        div     $t5, $t3
        mflo    $t4                             # columns, **x len**
        li      $t5, 0                          # flatten index, we will build (x, y) from it
        move    $t0, $a0
        move    $t1, $a1
loop:
        li      $t9, 0                          # mines count
        lb      $t2, ($t0)
        # check offseted cells
        div     $t5, $t3
        mflo    $t6                             # quotient, y coordinate
        mfhi    $t7                             # remainder, x coordinate
        # left
        subi     $t8, $t7, 1                     # left x coord
        # $t8 >= 0 && $t8 < 3 && lb == '*' => $t9++
        bltz    $t8, next_check
        bge     $t8, $t4, next_check
        # index is in range horizontally, safe to load
        lb      $t5, -1($t0)                     # character at offset (left)
        beq     $t5, '*', increment
# ! i have overlaps on t3 and t5 it wont work !
next_check:
        li      $t5, '0'
        add     $t5, $t3, $t9
        bne     $t5, '0', count
        li      $t5, ' '
count:
        beq     $t2, '\n', skip_count
        addi    $t5, $t5, 1                     # increment characters count (wihtou \n)
skip_count:
        sb      $t2, ($t1)                      # and store '\n'
        # increment both ptrs at the end
        addi    $t1, $t1, 1
        addi    $t0, $t0, 1
        bne     $t2, '\0', loop
end:
        # li      $t2, '\0'
        # sb      $t2, ($t1)
        jr      $ra

increment:
        addi    $t9, $t9, 1
        j       next_check
