# | Register | Usage        | Type    | Description                   |
# | -------- | ------------ | ------- | ----------------------------- |
# | `$a0`    | input        | address | null-terminated input string  |
# | `$a1`    | input/output | address | null-terminated output string |
# | `$t0-9`  | temporary    | any     | for temporary storage         |

# we have a grid of 3 by 3, at flatten index 5
# 5 / 3; lo(quot) = 1; hi(rem) = 2; (2, 1) 0-indexed
# 
# 1    2     3           hi, index-1-3..index-1
#
# 4  <cell>  5           mi, index-1, index+1
#
# 6    7     8           lo, index+1..index+1+3
#
# ...
# x..   
# ...
#
# index=3, 3/3=>lo=1;hi=0;
# left => index-1 => |0,2| does not include hi=0
# top => index-1-2 => |0,2| does include lo=1

.globl annotate

annotate:
        move    $t0, $a0                        # `$a0`
        move    $t1, $a1                        # `$a1`
        li      $t2, 0                          # width, row length
        li      $t3, 0                          # height, column length
        li      $t5, 0                          # first row flag
calc_width_height_loop:
        lb      $t4, ($t0)                      # character, cell or formatting such as `\n` or `\0`
        beq     $t4, '\0', write_loop_setup 
        beq     $t4, '\n', set_flag             # we bump into `\n` so we set first row flag
        addi    $t3, $t3, 1                     # right now we simply accumulate into `$t3` all characters count
        beq     $t5, 1, skip_increment          # if we set the flag we don't increment anymore
        addi    $t2, $t2, 1
        j       skip_increment
set_flag:
        li      $t5, 1
skip_increment:
        addi    $t0, $t0, 1
        j       calc_width_height_loop
write_loop_setup:
        div     $t3, $t2                        # divide all cells count by first row count
        mflo    $t3                             # quotient is the height
        li      $t4, 0                          # flatten cell index
        move    $t0, $a0
        move    $t1, $a1
write_loop:                                     # each iteration handle single cell
         li      $t5, 0                          # mine count for the cell
         lb      $t6, ($t0)                      # cell character
         beq     $t6, '\0', end
         beq     $t6, '\n', write_new_line
         beq     $t6, '*', write_mine            # after this line we start to process the cell
left_top: # (-1,-1) -> (1,1) 
        div     $t4, $t2 # all chars count / width
        mflo    $t8 # height, y
        mfhi    $t9 # x offset
        addi    $t8, $t8, 1 # get the offsets of the mine from the current cell
        addi    $t9, $t9, 1
        blt     $t9, $zero, right_bot
        blt     $t8, $zero, right_bot
        bge     $t9, $t2, right_bot
        bge     $t8, $t3, right_bot
        mul     $t7, $t8, $t2 # mul row by width
        add     $t7, $t7, $t8 # but we need to add also \n chars for each line so we can just add it
        add     $t7, $t7, $t9 # add back x offset to get total offset from ptr
        add     $t7, $t7, $a0 # get ptr at other cell we check to see if it's a mine
        lb      $t6, ($t7)
        bne     $t6, '*', right_bot
        addi    $t5, $t5, 1
right_bot: # (1,1) -> (-1,-1) 
        div     $t4, $t2 # all chars count / width
        mflo    $t8 # height, y
        mfhi    $t9 # x offset
        addi    $t8, $t8, -1 # get the offsets of the mine from the current cell
        addi    $t9, $t9, -1

        # move    $t4, $a0
        # li      $v0, 11
        # li      $a0, '\n'
        # syscall
        # move    $a0, $t8 # print
        # li      $v0, 1
        # syscall
        # move    $a0, $t4

        blt     $t9, $zero, no_mines
        blt     $t8, $zero, no_mines
        bge     $t9, $t2, no_mines
        bge     $t8, $t3, no_mines
        mul     $t7, $t8, $t2 # mul row by width
        add     $t7, $t7, $t8 # but we need to add also \n chars for each line so we can just add it
        add     $t7, $t7, $t9 # add back x offset to get total offset from ptr
        add     $t7, $t7, $a0 # get ptr at other cell we check to see if it's a mine
        lb      $t6, ($t7)
        bne     $t6, '*', no_mines
        addi    $t5, $t5, 1
no_mines:                                       # write character
        li      $t7, '0'                        # mine count as character
        add     $t7, $t7, $t5                   # add mine count
        bne     $t7, '0', non_zero_mine_count
        li      $t7, ' '                        # we render ' ' instead of '0'
non_zero_mine_count:
        sb      $t7, ($t1)
        addi    $t0, $t0, 1                     # todo: i prefer to increment everything at the end (it's easier to do arithmetics) but i have to repeat those 3 lines
        addi    $t1, $t1, 1
        addi    $t4, $t4, 1
        j       write_loop
write_new_line:
        sb      $t6, ($t1)
        addi    $t0, $t0, 1
        addi    $t1, $t1, 1
        # here we don't increment cell count
        j       write_loop
write_mine: # we need a diff actually between \n and * which we write here
        sb      $t6, ($t1)
        addi    $t0, $t0, 1
        addi    $t1, $t1, 1
        addi    $t4, $t4, 1
        j       write_loop
end:
        jr      $ra

